#pragma once

#include <fstream>
#include <string>
#include <unordered_set>

class target
{
public:
	static constexpr const char* tokens_header_name = "generated_tokens.hpp";
	static constexpr const char* lexemes_source_name = "generated_lexemes.cpp";
	static constexpr const char* lexemes_header_name = "generated_lexemes.hpp";

public:
	explicit target(std::string source)
	: m_source(std::move(source))
	, m_tokens_header(tokens_header_name)
	, m_lexemes_source(lexemes_source_name)
	, m_lexemes_header(lexemes_header_name)
	{
		if (!m_tokens_header.is_open())
			throw std::runtime_error(tokens_header_name + std::string(" could not be created"));

		if (!m_lexemes_source.is_open())
			throw std::runtime_error(lexemes_source_name + std::string(" could not be created"));

		if (!m_lexemes_header.is_open())
			throw std::runtime_error(lexemes_header_name + std::string(" could not be created"));

		init_tokens_header();
		init_lexemes_source();
		init_lexemes_header();
	}

	~target()
	{
		finish_tokens_header();
		finish_lexemes_source();
		finish_lexemes_header();
	}

	void add_symbol(const std::string& kind, std::size_t position, std::size_t line, std::size_t column)
	{
		m_tokens_header << "\t\tmake_token_t<"
					<< "decorator::token_kind::" << kind << ", "
					<< position << ", "
					<< line << ", "
					<< column << ">,\n";
	}

	void add_identifier(const std::string& identifier, std::size_t position, std::size_t line, std::size_t column)
	{
		add_lexeme(identifier);

		m_tokens_header << "\t\tmake_token_t<"
					<< "decorator::token_kind::identifier, "
					<< position << ", "
					<< line << ", "
					<< column << ", "
					<< "lexemes::" << identifier << ">,\n";
	}

	void add_integer(unsigned long long value, std::size_t position, std::size_t line, std::size_t column)
	{
		m_tokens_header << "\t\tmake_token_t<"
					<< "decorator::token_kind::integer, "
					<< position << ", "
					<< line << ", "
					<< column << ", "
					<< "static_cast<word_t>(" << value << ")>,\n";
	}

private:
	std::string m_source;
	std::ofstream m_tokens_header;
	std::ofstream m_lexemes_source;
	std::ofstream m_lexemes_header;
	std::unordered_set<std::string> m_lexemes;

	void add_lexeme(const std::string& lexeme)
	{
		if (m_lexemes.find(lexeme) == m_lexemes.end()) {
			m_lexemes.insert(lexeme);
			m_lexemes_source << "\tconst char lexemes::" << lexeme << "[] = \"" << lexeme << "\";\n";
			m_lexemes_header << "\t\textern const char " << lexeme << '[' << (lexeme.size() + 1) << "];\n";
		}
	}

	void init_tokens_header()
	{
		m_tokens_header.clear();
		m_tokens_header << "#pragma once\n\n"
			<< "#include <metalang/compiler/token.hpp>\n"
			<< "#include <metalang/types.hpp>\n"
			<< "#include \"" << lexemes_header_name << "\"\n\n"
			<< "// generated by generate_tokens\n\n"
			<< "namespace generated\n"
			<< "{\n"
			<< "\tusing namespace compiler::token;\n\n"
			<< "\tusing tokens = type_list<\n";
	}

	void finish_tokens_header()
	{
		m_tokens_header << "\t\tmake_token_t<decorator::token_kind::end_of_source, 0, 0, 0>\n";
		m_tokens_header << "\t>;\n}\n";
	}

	void init_lexemes_source()
	{
		m_lexemes_source.clear();

		m_lexemes_source << "#include \"" << lexemes_header_name << "\"\n\n"
			<< "// generated by generate_tokens\n\n"
			<< "namespace generated\n"
			<< "{\n"
			<< "\tconst char source[" << (m_source.size() + 1) << "] = \"" << m_source << "\";\n\n";
	}

	void finish_lexemes_source()
	{
		m_lexemes_source << "}\n";
	}

	void init_lexemes_header()
	{
		m_lexemes_header.clear();
		m_lexemes_header << "#pragma once\n\n// generated by generate_tokens\n\n";
		m_lexemes_header << "namespace generated\n{\n"
			<< "\textern const char source[" << (m_source.size() + 1) << "];\n\n"
			<< "\tnamespace lexemes\n\t{\n";
	}

	void finish_lexemes_header()
	{
		m_lexemes_header << "\t}\n}\n";
	}
};
